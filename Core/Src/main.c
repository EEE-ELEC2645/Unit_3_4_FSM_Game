// ELEC2645 Character FSM Demo
// ===========================
// This example demonstrates finite state machines (FSM) for game objects.
// 
// The character has an internal FSM with states: IDLE, WALKING, and DASHING.
// 
// KEY CONCEPTS:
// - Game objects can have their own internal FSM for behavior and animation
// - State transitions based on input (joystick) and button presses
// - Button press triggers dash state (temporary high-speed state)
// - Update/Render separation: logic updates happen separately from drawing
//
// Controls:
// - Joystick: Move character in any direction
// - Button (BTN3): Trigger dash ability
//
// Architecture:
// - update_character(): Updates FSM based on input (game logic)
// - render_game(): Draws everything to LCD (rendering only)
// - Character module: Encapsulates character FSM, sprites, and movement


// STM32 HAL headers (auto-generated by STM32CubeMX)
#include "main.h"
#include "tim.h"       // Timer 2 for PWM buzzer control
#include "usart.h"     // For serial output
#include "gpio.h"      // GPIO control
#include "adc.h"       // ADC for joystick input

// AUTO-GENERATED STM32 FUNCTION PROTOTYPES - DO NOT EDIT
void SystemClock_Config(void);
void PeriphCommonClock_Config(void);

// Buzzer library
#include "Buzzer.h" // Not used but included for completeness and future expansion of the demo to include buzzer functionality
#include "PWM.h"    // For PWM control of the LED 
#include "LCD.h"  // For LCD demonstration 
#include "Joystick.h" // include the Joystick driver functions
#include "Character.h" // Character object with FSM for game sprite

#include <stdint.h>
#include <stdio.h>
#include <math.h>

// ===== BUZZER CONFIGURATION =====
// Configure buzzer to use TIM2 Channel 3 (current hardware setup)
Buzzer_cfg_t buzzer_cfg = {
    .htim = &htim2,
    .channel = TIM_CHANNEL_3,
    .tick_freq_hz = 1000000,  // 1MHz timer clock (prescaler = 79 with 80MHz input)
    .min_freq_hz = 20,
    .max_freq_hz = 20000,
    .setup_done = 0
};

// ===== LCD CONFIGURATION =====
ST7789V2_cfg_t cfg0 = {
    .setup_done = 0,
    .spi = SPI2,
    .RST = {.port = GPIOB, .pin = GPIO_PIN_2},
    .BL = {.port = GPIOB, .pin = GPIO_PIN_1},
    .DC = {.port = GPIOB, .pin = GPIO_PIN_11},
    .CS = {.port = GPIOB, .pin = GPIO_PIN_12},
    .MOSI = {.port = GPIOB, .pin = GPIO_PIN_15},
    .SCLK = {.port = GPIOB, .pin = GPIO_PIN_13},
    .dma = {.instance = DMA1, .channel = DMA1_Channel5}
};

// ===== JOYSTICK CONFIGURATION =====
Joystick_cfg_t joystick_cfg = {
    .adc = &hadc1,
    .x_channel = ADC_CHANNEL_1, //A5 on Nucleo board
    .y_channel = ADC_CHANNEL_2, //A4 on Nucleo board
    .sampling_time = ADC_SAMPLETIME_47CYCLES_5,
    .center_x = JOYSTICK_DEFAULT_CENTER_X,
    .center_y = JOYSTICK_DEFAULT_CENTER_Y,
    .deadzone = JOYSTICK_DEADZONE,
    .setup_done = 0
};

// Joystick data structure to hold readings
Joystick_t joystick_data;

// ===== PWM CONFIGURATION =====
// Configure PWM to use TIM4 Channel 1 (current hardware setup)
PWM_cfg_t pwm_cfg = {
    .htim = &htim4,
    .channel = TIM_CHANNEL_1,
    .tick_freq_hz = 1000000,  // 1MHz timer clock (prescaler = 79 with 80MHz input)
    .min_freq_hz = 10,
    .max_freq_hz = 50000,
    .setup_done = 0
};

// ===== FSM STATE DEFINITIONS =====

// ===== NO OUTER FSM =====
// This demo focuses on a SINGLE CHARACTER FSM for the game sprite. There is no overarching game state machine in this demo.
// The character has its own internal FSM (IDLE/RUNNING/JUMPING) that runs continuously.



// ===== UTILITY FUNCTIONS =====

/**
 * @brief Redirect printf to UART for debugging
 */
int _write(int file, char *ptr, int len) {
    HAL_UART_Transmit(&huart2, (uint8_t*)ptr, len, HAL_MAX_DELAY);
    return len;
}

// ===== CHARACTER FSM VARIABLES =====
// Global character object
Character_t game_character;

// Dash button state
volatile uint8_t dash_button_pressed = 0;

// Last debounce timestamp for dash button
volatile uint32_t dash_button_last_interrupt_time = 0;

// Debounce delay in milliseconds - prevents multiple triggers from single button press
#define DEBOUNCE_DELAY 200

// ===== FUNCTION PROTOTYPES =====
void update_character(Joystick_t* joy);
void render_game(void);

/**
 * @brief Get character state name
 */
const char* get_char_state_name(CharacterState_t state) {
    switch (state) {
        case CHAR_IDLE:    return "IDLE";
        case CHAR_WALKING: return "WALK";
        case CHAR_DASHING: return "DASH";
        default:           return "???";
    }
}

// ===== Main Function =====

/**
  * @brief  The application entry point - Character FSM Demo
  * @retval int
  */
int main(void)
{
    /* MCU Configuration */
    HAL_Init();
    SystemClock_Config();
    PeriphCommonClock_Config();

    /* Initialize peripherals */
    MX_GPIO_Init();
    MX_USART2_UART_Init();
    MX_ADC1_Init();  // Initialize ADC for joystick
    
    // Initialize LCD first (this sets up GPIOB pins)
    LCD_init(&cfg0);

    // Initialize TIM4 AFTER LCD to avoid GPIO conflict on PB6
    MX_TIM4_Init();
  
    // Initialize Joystick
    Joystick_Init(&joystick_cfg);
    
    // Initialize Character
    Character_Init(&game_character);
    
    // make screen black
    LCD_Fill_Buffer(0);
    LCD_Refresh(&cfg0);

    // Startup animation
    LCD_printString("Character",  15, 50, 1, 4);
    LCD_Refresh(&cfg0);
    HAL_Delay(500);
    
    LCD_Fill_Buffer(0);
    LCD_printString("FSM+Dash",  30, 50, 1, 4);
    LCD_Refresh(&cfg0);
    HAL_Delay(500);

    // Display instructions
    LCD_Fill_Buffer(0);
    LCD_printString("Move Joystk", 10, 30, 1, 2);
    LCD_printString("Press Btn", 10, 60, 1, 2);
    LCD_printString("to", 70, 85, 1, 2);
    LCD_printString("DASH!", 45, 110, 1, 3);
    LCD_Refresh(&cfg0);
    HAL_Delay(2000);

    // Initialize PWM for LED control
    PWM_Init(&pwm_cfg);
    PWM_SetFreq(&pwm_cfg, 1000);
    PWM_SetDuty(&pwm_cfg, 0);
    
    // Ensure LD2 on PA5 starts OFF
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);

    printf("Character FSM Demo initialized.\n");

    while (1)
    {
        // ===== CHARACTER FSM MAIN LOOP =====
        // Simply update and render the character
        
        // Read joystick input
        Joystick_Read(&joystick_cfg, &joystick_data);
        
        // Update character FSM (logic only)
        update_character(&joystick_data);
        
        // Render everything to screen
        render_game();
        
        // Small delay to prevent overwhelming the LCD
        HAL_Delay(30);
    }
}

// ===== UPDATE & RENDER FUNCTIONS =====

/**
 * @brief Update character logic (FSM, movement)
 * 
 * This function handles all game logic updates:
 * - Processes input (joystick and button)
 * - Updates character FSM state transitions
 * - Updates animation frames
 * 
 * Separated from rendering for cleaner code architecture.
 */
void update_character(Joystick_t* joy) {
    // Check if dash was pressed and clear the flag
    uint8_t dash_pressed = dash_button_pressed;
    dash_button_pressed = 0;
    
    // Update character FSM with current input
    Character_Update(&game_character, joy, dash_pressed);
}

/**
 * @brief Render the game to the LCD screen
 * 
 * This function handles all rendering/drawing:
 * - Clears the screen buffer
 * - Draws character sprite
 * - Draws debug information (state, position)
 * - Refreshes LCD to display the frame
 * 
 * Separated from game logic for cleaner code architecture.
 */
void render_game(void) {
    // Clear screen buffer
    LCD_Fill_Buffer(0);
    
    // Draw character at current position with animation
    Character_Draw(&game_character);
    
    // Draw debug info
    LCD_printString("St:", 10, 5, 1, 2);
    LCD_printString((char*)get_char_state_name(game_character.state), 60, 5, 1, 2);
    
    char pos_str[24];
    sprintf(pos_str, "X:%d Y:%d", game_character.x, game_character.y);
    LCD_printString(pos_str, 120, 5, 1, 2);
    
    // Refresh LCD to display this frame
    LCD_Refresh(&cfg0);
}

// ===== Interrupt Callback =====

/**
  * @brief EXTI line detection callback - Dash Button
  * @param GPIO_Pin: Specifies which GPIO pin triggered the interrupt
  * 
  * @note This callback is triggered when the user presses the dash button (BTN3).
  *       The interrupt sets a flag that tells the character to start dashing.
  *       We keep ISRs SHORT and SIMPLE - just set a flag. The main loop handles everything else.
  *       Never use HAL_Delay() in an interrupt handler as it can cause the system to hang!
  */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  uint32_t current_time = HAL_GetTick();
  
  // Check if dash button (BTN3) was pressed
  if (GPIO_Pin == BTN3_Pin)
  {
    // Debouncing: ignore interrupts that happen too quickly (within 200ms)
    if ((current_time - dash_button_last_interrupt_time) > DEBOUNCE_DELAY)
    {
      dash_button_last_interrupt_time = current_time;
      
      // Set flag to trigger dash in the character FSM
      dash_button_pressed = 1;
    }
  }
}

// ==== AUTO-GENERATED STM32 FUNCTIONS ====
// DO NOT EDIT UNLESS YOU KNOW WHAT YOU ARE DOING! 


/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 10;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief Peripherals Common Clock Configuration
  * @retval None
  */
void PeriphCommonClock_Config(void)
{
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};

  /** Initializes the peripherals clock
  */
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RNG|RCC_PERIPHCLK_ADC;
  PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
  PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_PLLSAI1;
  PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSI;
  PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
  PeriphClkInit.PLLSAI1.PLLSAI1N = 8;
  PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
  PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV4;
  PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
  PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK|RCC_PLLSAI1_ADC1CLK;
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
  {
    Error_Handler();
  }
}



/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
